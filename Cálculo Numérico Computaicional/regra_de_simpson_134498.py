# -*- coding: utf-8 -*-
"""regra_de_simpson_134498.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tsyV68JBWyZO-O1oBYgES7f9kUMoy7pl

#Autor: Matheus Teixeira de Souza

#Resumo:
**A regra 1/3 de Simpson, é mais precisa do que o método do trapézio, pois ela utiliza uma parábola para aproximar uma função num intervalo de integração, assim, tendo um erro menor.**

**Para calcular é necessário ter três pontos que interpolem a função.
A função f(x) é chamada de acordo com os limites definidos por a e b, após utilizar a fórmula para calcular a integral aproximada é possível calcular o erro aproximado e o erro verdadeiro.**
"""

#Importando a biblioteca sympy para realizar o cálculo da quarta derivada da função
import sympy as sp


"""
    Implementa da regra de Simpson para aproximar uma função no intervalo de integração.

    Parâmetros:
    a : Início do intervalo.
    b : Fim do intervalo.
    valor_real : O valor real buscado da integral da função.

    O que é retornado?
    A Estimativa do valor da função no ponto z, juntamente com o erro relativo percentual verdadeiro.
"""


#Definindo início e fim do intervalo de integração (a e b)
a = 0
b = 0.8

#Definindo o valor real da integral do exemplo
valor_real = 1.640533

#Definindo a função do exemplo
def f(x):
    return (0.2 + 25*x - 200*x**2 + 675*x**3 - 900*x**4 + 400*x**5)

#Definindo o valor da quantidade de subintervalos
n = 4

#Calculando o tamanho do subintervalo
h = (b-a)/n

#Definindo os valores das somas pares e ímpares que irão ser adicionados a cada iteração
somas_pares = 0
somas_impares = 0

#Itera do segundo até o último valor, retirando o primeiro
for i in range(1,n):
    #Se for par adiciona f(a+1*h) a variável somas_pares para pegar a soma de todos valores quando forem pares
    if i%2 == 0:
        #print(f" Iteração {i}: f(x({i}) = f()")
        somas_pares = somas_pares+f(a+i*h)
    #Se não faz a mesma coisa para os ímpares, porém adiciona a variável somas_impares
    else:
        somas_impares = somas_impares+f(a+i*h)

#Utilizando a fórmula da regra de 1/3 de Simpson para calcular o valor da integral aproximada
l = (h/3)*(f(a)+ (4 * somas_impares) + (2 * somas_pares) + f(b))


#Calcula o erro verdadeiro utilizando o valor real e também retorna em porcentagem
erro_verdadeiro = abs(valor_real - l)
ev_percent = (erro_verdadeiro/abs(valor_real)) * 100

# Define a variável simbólica
x = sp.symbols('x')

# Calcula a quarta derivada de f(x)
f_4th_derivative = sp.diff(f(x), x, 4)

# Calcula a integral da quarta derivada no intervalo [a, b]
integral_f_4th_derivative = sp.integrate(f_4th_derivative, (x, a, b))

# Calcula o valor médio da quarta derivada
average_f_4th_derivative = integral_f_4th_derivative / (b - a)

# Converte o valor médio para um número flutuante (opcional)
average_f_4th_derivative = average_f_4th_derivative.evalf()

#Calcula o erro aproximado
erro_aprox = -(h**5*n/180 )* average_f_4th_derivative


#Retornando a aproximação da integral, o erro verdadeiro e o erro aproximado
print(f"Aproximação da integral definida de f(x) no intervalo [a,b]: {l}")
print(f"Erro Verdadeiro: {ev_percent:,.2f}%")
print(f"Erro Aproximado: {erro_aprox:,.6f}")