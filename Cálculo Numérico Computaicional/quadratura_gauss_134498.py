# -*- coding: utf-8 -*-
"""quadratura_gauss_134498.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AUKoCAzvBXDqDlG1fX59ts0TmXb9QrAB

#Nome: Matheus Teixeira de Souza
#Resumo:

**O método da Quadratura de Gauss é mais preciso para determinadas situações e formas por exemplo que o método do trapézio, pois ela é livre para calcular a área sob uma reta ligando quaisquer pontos da curva, que quando esses pontos são escolhidos da melhor maneira, é possível encontrar uma reta que seja o meio termo entre os erros positivos e negativos.**

**É dada uma função e seu valor real, juntamente com o extremo inferior e superior, o número de pontos da quadratura, escolhido os pontos e colhetado as absissas dos pontos e pesos de cada uma para a fórmula para aplicar o método.**

**Assim, utilizando as fórmulas, calculamos a transformada das abscissas e também dos pesos, e a cada iteração é somado o valor da multiplicação entre as duas, assim, obtendo o valor da integral aproximada. E após isso, é possível calcular o erro entre a aproximada obtida e a integral real.**
"""

#Realizando as importações das bibliotecas math e numpy
import math
import numpy as np

#Retorna a função f(x)
def f(x):
    return 0.2 + 25*x - 200*(x**2) + 675*x**3 - 900*(x**4) + 400*(x**5)  #Retorna o valor da função de acordo com x

"""
    Implementa a Quadratura de Gauss
    Parâmetros:
        a,b : Intervalo de integração
        valor_real : Valor real da integração que buscamos
        n : Número de pontos da quadratura
        x : Abscissas dos pontos
        c : Pesos definidos para a fórmula

    O que é retornado?
    A aproximação da integração real
"""

#Dados fornecidos no exemplo
a = 0       #Define o extremo inferior da integral do exemplo
b = 0.8     #Definindo o extremo superior da integral do exemplo
valor_real = 1.640533  #Define o valor real
n = 2       #Número de pontos de quadratura desejados do exemplo


x,c = np.polynomial.legendre.leggauss(n)  #Comando da biblioteca Numpy que calcula os pontos de amostra e pesos para a quadratura de Gauss-Legendre

c_t = np.zeros(n)   #Iniciando um vetor do tamanho dos pontos da quadratuda para colocar os pesos transformados
x_t = np.zeros(n)   #Iniciando um vetor do tamanho dos pontos da quadratuda para colocar a abscissa transformada

#Função que aplica a transformada
def abscissa_transformada(x):
    soma = 0  #Iniciando a variável soma como 0
    #Percorre de 1 a n
    for i in range(0,n):
        x_t[i] = ((b+a) + (b-a) * x[i])/2 #Calculando a abscissa transformada pela fórmula
        c_t[i] = ((b-a)/2) * c[i]         #Calculando o peso transformado pela fórmula
        soma = soma+(c_t[i]*f(x_t[i]))    #Adicionando a multiplicação entre o peso transformado e f(abscissa transformada) a variável soma

    return soma   #Retornando o resultado final da variável soma

#Função que calcula o erro
def calcula_erro(integral_aproximada):
    erro = abs(valor_real-integral_aproximada)    #Calcula o erro com o valor real - a integral aproximada
    return erro         #retorna o erro

integral_aproximada = abscissa_transformada(x)      #Chamando a função que calcula a integral aproximada
print(integral_aproximada)                          #Printando a integral aproximada
print(calcula_erro(integral_aproximada))  #Printando o erro entre o valor real e o valor obtido