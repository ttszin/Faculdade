# -*- coding: utf-8 -*-
"""interpolação_newton_134498.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IuugLTsFHN2rT9yy488-KJWIWtIGHaWE

#Autor : Matheus Teixeira de Souza

#O método de interpolação polinomial de Newton é um dos métodos de interpolação polinomial que visa aproximar funções por polinômios de grau até n. O objetivo é facilitar o cálculo de funções em pontos não dados, ou seja, interpolar significa calcular pontos internos não dados.

#Assim como a de Lagrange é uma forma que não necessita resolver sistemas lineares, e ainda possui a vantagem de caso querer aumentar os nós de interpolação, basta adicionar um termo ao polinômio obtido anteriormente.
"""

import numpy as np  # Importa a biblioteca NumPy, que facilita operações matemáticas e manipulação de arrays


"""
    Implementa a Interpolação Polinomial de Newton para estimar o valor da função em um ponto z.

    Parâmetros:
    x : Lista com as coordenadas x dos pontos conhecidos.
    y : Lista com as coordenadas y dos pontos conhecidos.
    z : O ponto onde queremos estimar o valor da função.

    O que é retornado?
    A Estimativa do valor da função no ponto z, juntamente com o erro relativo percentual verdadeiro.
"""


# Dados fornecidos no exemplo
x = [1, 4, 6, 5]  # Lista dos valores de x (pontos de entrada)
y = [0, 1.386294, 1.791759, 1.609438]  # Lista dos valores correspondentes de f(x)
z = 2  # Valor em que queremos calcular a interpolação (aproximar ln(2))

def interpolacao_newton(x, y, z):
    n = len(x) - 1  # Calcula o número de pontos, dado que temos n+1 pontos fornecidos

    # Passo 3: Inicializa a lista das diferenças divididas
    d = np.zeros((n+1, n+1))  # Cria uma matriz de zeros de tamanho (n+1) x (n+1) para armazenar as diferenças divididas
    for i in range(n+1):
        d[i][0] = y[i]  # Preenche a primeira coluna da matriz com os valores de y

    # Passo 4: Calcula as diferenças divididas de ordem superior
    for j in range(1, n+1):  # Itera sobre as colunas da matriz
        for i in range(n+1-j):  # Itera sobre as linhas da matriz
            # Calcula as diferenças divididas de ordem superior e armazena na matriz
            d[i][j] = (d[i+1][j-1] - d[i][j-1]) / (x[i+j] - x[i])

    # Passo 5: Inicializa a variável xtermos
    xtermos = 1  # Começa com 1, pois xtermos será usado para calcular os termos do polinômio de Newton

    # Passo 6: Inicializa yint com d0,0
    yint = d[0][0]  # A interpolação começa com o valor da diferença dividida de ordem zero (d[0][0])

    # Passo 7: Calcula a interpolação de Newton
    for ordem in range(1, n+1):  # Itera sobre as ordens do polinômio
        xtermos *= (z - x[ordem-1])  # Atualiza xtermos multiplicando pelo fator (z - x[ordem-1])
        yint += d[0][ordem] * xtermos  # Adiciona o termo correspondente ao polinômio interpolador

    # Passo 8: O valor de yint agora contém o resultado da interpolação
    return yint  # Retorna o valor interpolado (estimativa de ln(2))

# Calcula a interpolação de Newton de terceiro grau
resultado = interpolacao_newton(x, y, z)  # Chama a função de interpolação com os dados fornecidos

# Valor verdadeiro de ln(2) para comparação
valor_verdadeiro = 0.6931472  # Armazena o valor verdadeiro de ln(2) para cálculo do erro

# Cálculo do erro relativo percentual verdadeiro
erro_relativo_percentual = abs((valor_verdadeiro - resultado) / valor_verdadeiro) * 100  # Calcula o erro percentual

# Exibe os resultados
print(f"Estimativa de ln(2) usando interpolação de Newton de terceiro grau: {resultado}")  # Mostra a estimativa
print(f"Erro relativo percentual verdadeiro: {erro_relativo_percentual:.6f}%")  # Mostra o erro relativo percentual